# 统一数据模型和数据框架

## 状态管理需要统一的数据框架

 所谓状态管理可能在不同语境下有不同指代。在这里我们将其具体职责定义为：

- 定义数据的结构
- 增删查改数据
- 观察捕获数据变更并作出响应

一般而言，这部分的实现都是手写，比如：

- 定义一些数据类型来表达业务逻辑
- 在这些类型上实现各自封装继承访问方法，和具体业务方法。并实际使用来完成业务需求
- 采用一些观察者模式的发布订阅组件，或者事件，来做一些数据变更后的自动响应。

对于简单小型应用，这没有什么问题。但是对于逻辑和数据结构复杂，数据量大，需要长期开发的维护的大型富状态应用（比如编辑器）和基础软件，上述实现的开发工作量就非常高，非常重复和易错，也不方便观测和调优性能。在这种情况下，我们需要一个统一的数据框架来做状态管理。数据框架对于上述类型的软件来说是至关重要的基础，从我的实践观察来说可以断言，这部分内容如果没有投入足够多的前期建设，扎实做好基础，那么整个项目长期而言技术上一定会陷入困境，以至于其所有应用层面的功能实现如同空中楼阁。

### 数据框架如何解决问题？

采用统一的数据框架能够解决问题，是因为这种做法实现了业务数据模型的「元数据化」。即：以数据的方式的来统一建模维护业务本身的数据形态。

为了实现业务数据形态本身的建模，我们就必须适配或修改业务数据形态，使其满足一套统一的「数据模型」。

假设你的业务数据都满足某种统一的数据模型，存储于某数据框架内，那么就可以

- 采用统一查询的方式（api）来增删查改数据
  - 无需手工编写无数的数据的增删查改方法
    - 自动实现深浅拷贝
  - 数据的存储查询修改可以在数据框架被统一的优化
- 采用统一的方式做数据验证，比如编写和配置声明式的规则
  - 无需手工编写和调用无数的检查方法，为数据的正确性提供完善保证
- 自动实现IO相关的能力
  - 对接其他通用数据建模语言定义的外部数据源进行数据交换，而不需要编写任何loader和exporter
  - 自动生成其他语言或者格式的接口实现，比如c FFI，protobuffer
  - 自动实现不同版本的数据兼容机制
- 自动的实现所有数据的精确变更观测，提供响应式增量计算框架的数据源
  - 自动的为所有数据实现增量的序列化反序列化和外部存储的持久化（[增量保存](../../editor-engineering/database-incremental-persistency.md)）
  - 自动的为所有数据实现增量的undo redo
  - 实现版本控制，协同编辑

基于统一的数据模型，我们编写的代码是针对**任何**类型的通用实现，而不是针对每一种/某一种**具体**类型编写实现。所以任何数据处理和存储的逻辑，其代码量完全和数据类型的复杂程度无关，不存在任何和具体数据关联的偶然复杂度。

编写大型应用在工程上的困境，就在于无法控制的状态维护相关的偶然复杂度导致的开发维护成本。数据框架和统一数据模型能够完全避免偶然复杂度的，实现从N到1的成本缩减，所以是工程上必需的基础设施。

### 分离数据形态定义和存储实现

通过数据框架来管理和存储数据，数据的存储方式，其实只是数据形态的一部分。数据的存储方式是可以配置化的。

数据的存储实现决定了数据的访问性能和内存消耗。

- 比如可以结合对消费行为的知识，通过调整数据的存储方式来提升cache命中率来提升性能。
  - 用户可以关联几个field在内存中指定采用AOS来存储
  - 多数据interleave，存储顺序
- 比如可以结合对数据分布的知识，通过调整数据的存储方式来节省内存。
  - 根据数据的稀疏性来决定是否采用hash容器，以性能换内存
  - 利用多数据之间的互斥关系来节省内存

因为上述的知识有可能随着业务逻辑的变迁而改变，所以数据的最佳存储方式也需要调整。得益于分离的数据形态定义和存储实现，存储方式的配置化使得这样的改动非常简单，这种灵活变更的能力这对于传统方式是不可想象的。因为这类变更是容易的（即数据库调优问题），使得通过调整数据存储实现，来探索性能优化空间和快速定位修复数据访问相关的性能问题的成为可能。

## 采用类关系型数据库作为统一的数据框架

我认为应该采用关系型数据模型，作为统一数据模型。应该采用「in-memory 类关系型数据库」作为数据框架的实现。

采用关系型数据模型的原因是

- 成熟，有诸多设计和实现可以参考
  - 可以直接对接到成熟的关系型数据库实现作为实际的存储层
  - 有正式的数学研究作为长期理论支撑
- 简单，但是足够松散，可以支持所有的数据结构
  - 一个最minimal的版本可以是：数据表就是若干数据容器的集合，数据库就是若干数据表的集合。不包含任何约束
  - 可以渐近的完成基础建设，逐步添加外键，约束等能力，同时这些能力能够逐步的提高整体数据的完整性并更好的支持上层能力
  - 实现简单，不依赖任何特别的编程语言特性
- 其典型的访问和底层存储模式适合对性能和消耗敏感的大型应用
  - 比如连续内存，按列存储

为了方便后续给予关系模型数据框架的讨论，这里我们给出简单的定义以对齐相关的名词术语：

- table为数据表，database由多张table构成
- 数据表中每一列（field）数据为component，一张table由多个component构成
- entity为基本的数据单元，为table中的一行。
  - entity通过handle来随机O(1)寻址
  - entity的component数据随entity创建而创建，销毁而销毁
- 如果某个component存储的是指向table的handle，那么这个component属于foreignkey 外键
  - 外键可以指向自己的table

基于该数据模型的扩展讨论

- [数据模型的所有权](./database-ownership-model.md)
