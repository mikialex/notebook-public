# 增量计算的基本原理

增量计算是一类至关重要的性能优化，任何富状态小变更特征的系统，比如UI框架，实际上都是增量计算框架。本文尝试给出其一般的原理分析。

考虑某纯函数将输入 A 执行某种计算，输出B的过程。增量计算是指在A的部分发生变化时，我们采用某些优化方式，使得可以完成相同的计算任务（输出B）但减少计算的开销。

### 原子性数据 和 数据的KV解构

Input A 和 Output B 的实际结构可以抽象为某种KV Map。

其中V是指某种原子性数据。所谓原子性的数据指的是逻辑上只能被作为一个整体一起修改的数据。

原子性数据的定义不取决于数据类型本身，而取决于业务的数据修改的模式。这和是否atomic类型没有关系，和是非基本数据类型无关。如果一些数据数据总是一起被修改，那么这些数据就被视作一个原子性数据。

其中的K被认为是V的一种唯一的寻址方式。

- 对于线性容器，index
- 对于map，就是map的key
- 对于struct就是其field
- 寻址是可以嵌套的，以支持任意的复杂数据

## 变更信息

显然，实现增量计算必须依赖「A部分发生变化」的额外信息。

对于原子性数据只需要记录其是否发生了变化。因为数据本身没有内部的观测粒度。

我们实际讨论的变更信息，对于我们数据KVMap解构的想法来看，可以认为是

- 发生变化的K的集合
- 被删除的K的集合
- 新创建的K的集合

除了原子性数据内容本身变化，原子性数据的生命周期变化（创建和销毁）的信息也需要记录。因为这样可以支持input的动态liveness。

### 如何获得变更信息

- 在A被修改时，由修改者记录到某个地方
- 在执行增量计算时，现场通过diff的方式，来计算出变更信息

## 增量计算的实现

任何计算过程，都可以视作是一个原子数据集合计算出另一个原子数据集合。在这个计算过程中，会创建出一系列临时的原子数据。若干个原子数据原子的计算出另一个原子数据。

计算可以认为是一个原子数据构成的计算图，其中图的边即计算的依赖，图的输入节点集合即我们的输入，图的输出节点即我们的输出。我们将这样的计算图称之为计算的依赖结构或计算结构。

增量计算的实现方式是：

- 以某种方式维护这样的计算依赖结构
- 根据这样的计算结构，和上述的变更信息，避免不需要执行的计算
- 对于实际上需要执行计算的节点，通过cache中间过程的原子数据来减少需要执行的计算

同一个计算需求，可以有（可能是任意）多个能够完成计算的计算图/计算依赖结构。虽然他们都能够完成计算的需求，但是显然其中一些结构比另一些结构更加适合更加有效的实现增量计算。

### 计算依赖结构的动态性

计算依赖结构的可能是具有动态性的，即计算依赖结构本身可以由（一部分）input（input的内容和liveness）决定，以及由input关联的中间数据决定。

解决计算依赖结构的动态性是增量计算的难点。绝大多数实际场景都是动态场景。

在这种情况下，某些简单的情况可能可以分析出input的动态性和计算结构动态性的关系。但是一般的通用情况我们需要先执行实际的计算，边计算边收集，才能获得其具体的计算依赖结构。

因为依赖结构是动态的，所以维护依赖结构的持久化临时数据，和cache，其lifetime也是动态的。在边计算边维护和更新这些数据的同时，还要及时销毁不再需要的这些数据。

依赖结构的维护可能具有无法忽视的内存/性能开销，但实际上即便是具有动态性的依赖结构，其中大部分的依赖实际上不具备动态性。但是如果采用最一般的上述方案，我们需要记录所有的中间数据对中间数据的多对多关系，这些数据在某些场景下可能会消耗非常多的常驻内存，并付出巨大的更新成本。一个好的增量计算框架，需要能够兼顾最一般的动态性问题，同时对于其中大部分的静态子问题，避免在实际内存中记录依赖，因为其静态的计算逻辑本身就静态的隐式的存储了依赖关系。使得维护计算依赖结构的这一过程成本合理。比如考虑一个vec简单的map到另一个vec，一般的考虑，我们需要存储每一项一一对应的依赖关系，但实际上因为我们知道这是map，map本身就是一一对应的依赖关系。

如果一个计算本身input高度可变，增量计算可能是没有意义的。同样如果一个计算的动态计算结构的存储维护成本非常高昂，增量计算也可能是没有意义的。不同的增量计算框架可以以不同的成本解决不同的动态性的问题，对于动态性非常高的业务逻辑，和动态性非常低的业务逻辑，可能需要不同的增量计算实现。

### 计算依赖结构的粒度

因为原子数据的划分是逻辑上的不是物理上的，所以计算时中间原子数据的划分也是逻辑上的，所以计算图实际描述的计算的粒度是主观决定的。过于精细划分的计算依赖，会消耗更多资源，但可能并不会带来有意义的性能提升。跳过一整块一整块的计算是有意义的，但是跳过一个一个加减法是没有现实意义的（因为甚至抵不过branching的cost）。所以实际上我们需要管理依赖的数据，是计算过程中中间数据的极少部分。这些中间原子数据的划分粒度应该取决于这些中间数据的消费者依赖的粒度。

## Cache

Cache（中间计算结果的缓存）对于增量计算来说并不是必需的，是否需要cache取决于计算的依赖结构。比如上述map的计算图，每一个input节点都只对应一个output节点，所以我们就完全不需要cache来控制变更传播的范围，依然能实现有效的增量计算。

即便对于某处中间计算理论上需要cache，实际上是否应该设置cache应取决于该cache是否能大概率有效被使用，即该中间数据数据是否低频率变化。每一个中间计算结果都有一个变更概率，而这些概率由最上游input的数据变更概率集合来决定。
