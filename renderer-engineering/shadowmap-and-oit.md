# 预过滤 Shadowmap 和 OIT

预过滤 Shadowmap 和 OIT（顺序无关透明）问题 是类似的。都涉及到如何对离散函数高效近似表达的问题。

## 预过滤 Shadowmap

Shadowmap：通过预计算光照方向的深度图，对于某个着色表面，通过判断该表面距离光源的深度和预计算的深度进行比较来决定是否被遮挡。shadowmap的深度图是一种预计算LUT。

PCF：在查询深度图时，对附近一个范围的深度图进行查询，计算这些查询通过遮挡测试的比例，作为被遮挡的比例（遮挡不再是bool，而是比例），由此来实现软阴影

过滤：

- 一般是指图像处理中的卷积运算，以去除某种频率的信号。
- 在图形学一种简化的语境下，指对附近（无论是时间还是空间）的数据/信号，取平均（一种简单卷积）来去除高频信息（边缘，锯齿）
- 上述的简单过滤，在图形硬件上可以被高效实现。

PCF相当于对深度图的测试结果进行过滤，对于PCF N个shading point，如果需要M个过滤sample，那么需要N * M次计算（采样和测试）。

预过滤 Shadowmap 指的是通过某种方式，使得 N个shading point 只需要N次计算即可完成软阴影。某种方式指：

- 调整遮挡判断/计算（估计）遮挡比例的方式
- 调整存储的LUT的内容（可能不是简单的深度图）

预过滤中的「过滤」，一般指的是上述调整后的LUT内容，可以直接采用图形硬件的高效简单过滤能力，实现M次采样的后过滤效果，来控制软阴影的范围

PCF是预过滤技术的Ground truth，好的预过滤实现应该可以近似的达到PCF的效果

### 预过滤的实质

因为预过滤是为了达到PCF的效果，所以我们先讨论PCF的实质：

深度图中某个范围内，其中的深度数据，构成了一个深度分布的函数。这个函数完全是数值的离散的，而不是解析的连续的。PCF的计算，实际上就是对该函数，输入某测试深度进行求值。

所以如果我们以某种方式，per depth pixel的去表达这个给定range的深度分布函数（CDF），那么可以实现软阴影的计算。

深度分布函数的表达方式，肯定不能存储实际的离散分布，否则实际上还是PCF的另一种形式。我们需要找到一种离散函数的近似表达方式，其具备：

- 固定存储开销
  - 每个分布数据只存储非常小的信息，比如几个float
  - 和实际分布无关的，和要做过滤的范围无关
- 固定计算开销
  - 生成这样的表达方式的计算成本，其计算成本是固定的 和实际分布无关的，和要做过滤的范围无关
  - 从这种表达方式来查询深度分布，其计算成本是固定的 和实际分布无关的，和要做过滤的范围无关
- 这种表达形式 可以实现上述的depth space的简单过滤，以直接实现过滤的范围，软阴影范围的控制

所以找到预过滤的算法，变成了一个和图形无关的，如何高效编码（encode）任意离散函数的纯数学问题。

另外，因为深度分布函数的输出就是被遮挡的比例（概率），所以我们可以任意的修改遮挡测试的定义和解释，甚至不需要讨论某个sample是否通过测试的bool结果的概念，只要结果满足我们需要的软阴影特征即可。

### 预过滤的实现

- 基于概率方法，存储深度cdf的多阶矩 来拟合实际分布。深度和深度的平方被过滤（平均）正好就是期望和方差，n阶矩也是如此。
  - VSM：存储和记录深度（1阶矩）和深度的平方（2阶矩），然后直接使用切比雪夫不等式（切比雪夫不等式就是低阶矩的特殊情况）作为深度分布函数的估计。
  - Moment SM：就是强化版的VSM，不仅使用了期望和方差，还使用了高阶矩（>2），效果更好，成本更高
- 基于多个简单函数线性组合的方式，通过存储系数来 来拟合实际分布。因为变成了多个基函数的线性组合，那么自然的，多个分布的过滤（平均）就是其线性组合系数的过滤（平均）
  - CSM(卷积)：使用三角函数作为基函数，存储频率系数。成本高，现在基本不做使用
- ESM：直接使用一个adhoc的可以被预过滤的，形态合理的深度分布

### 其他

很多讲解预过滤shadowmap的资料中，都会说我们通过调整depth test的方式，配合如何修改存储哪些数据来实现。这种说法非常（至少令我）困惑，因为depth test永远应该只是bool结果，实际上所谓的depth test指的是上述depth的分布函数（左移到测试深度）。或者说，即便完全不过滤，1px的depth数据里存储的被认为也是过滤后的结果，所以非bool的depth test也有实际意义。

## OIT

OIT 问题 和预过滤shadowmap是一样的问题。

OIT正确的mental model是：对于任意一个绘制像素，存在一个深度-> transmittance的函数。给定一个截断深度（比如一个不透明物体），获取的transmittance over到某个target color（不透明物体的颜色）就是最终颜色。 如果是纯半透明，那么截断深度就是无穷远，target color就是场景的背景。

那么OIT问题就变成了一个纯数学问题：我们需要找到一种离散函数的近似表达方式，其具备：

- 固定存储开销
  - 每个分布数据只存储非常小的信息，比如几个float
  - 和实际分布无关的
- 固定计算开销
  - 从这种表达方式来查询transmittance，其计算成本是固定的 和实际分布无关的
  - 这种表达方式支持增量的固定成本的encoding。因为场景光栅化绘制时每次只能绘制一个半透明的表面（相当于上述分布是逐步被修改出来的）

### OIT的实现

- 精确方案： raytracing，完整保留上述函数
- 精确但是控制容量的方案：depth peeling，或者single pass利用atomic image。来保留函数最靠前的几个表面/转折点信息
- 近似方案：
  - 纯粹的adhoc hack： weighted OIT
  - 基于概率的方法：Moment OIT，和Moment Shadow类似
  - 使用小波来近似encode <https://osor.io/OIT>
