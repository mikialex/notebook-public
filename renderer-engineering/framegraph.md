# 关于Framegraph架构的观点

虽然现在很多实现都采用了framegraph作为渲染器的主要架构方案，但我并**不**认为这一做法是合理的。主要原因是

- 在大部分场景，其收益远不足以覆盖其付出的工程代价
- 有其他（可能是更好/更简单的）替代做法来解决相同的问题

framegraph架构和普通的做法在编程模式上的区别：

- 普通的做法，即所谓即时模式的绘制，用户直接过程式的表达渲染逻辑。
- 采用framegraph，用户需要构造一个dag的数据结构，用这个数据结构表达渲染逻辑，然后交由framegraph的运行时完成实际的绘制提交。

framegraph 主要（帮助）解决什么问题？

- 生成同步相关的指令（比如barrier，events）
  - 相比其他方案（比如记录per resource的状态并计算状态转移），可能具有一定的性能优势
- 优化pass结构和提交顺序和结构，做一些scheduler方面的改进
- 复用临时资源，减少内存消耗
- 剔除不必要的pass
- 能做很cool的visualization

## 关于同步指令生成问题

观点：即便采用传统的即时模式，也可以生成正确的同步指令。

显然的，比如一个具体做法是：即时模式提交的渲染命令，不直接提交到图形api，而是暂存直到sumbit时。在sumbit之前，做完整的精确的依赖分析，生成同步相关的控制（wgpu，或者任何非显式同步的图形api都是这么做的）。用户不需要以另一种方式（比如framegraph）来表达绘制上的依赖关系，绘制上的依赖关系信息实际上已经完整的存在于渲染命令中。

观点：让用户显式表达资源的读写依赖关系的做法，是不合理的。

让用户显式表达资源的读写依赖关系，唯一的好处，是省去了让运行时从渲染指令分析出合理同步指令的开销。所以framegraph将用户编写正确和完备手工同步指令的痛苦，转移到了编写正确且完备的依赖关系表达的痛苦。而这件事情的确比同步要简单，但依然是易错的。而且出错后的调试依然是困难的。 某些设计采用折中的做法，让用户表达一部分的显式依赖，然而这并不解决问题。显式的部分做check，就完全没有性能优势，不做check就调试困难。所以只能通过配置来开关。这好比production版本关闭boundcheck一样，是有争议的一种做法。

观点：即便框架完全采用自动的同步指令分析生成，依然可以大幅优化同步指令生成的性能

只要渲染指令序列表达的资源的identity和其依赖关系不变，那么其内部同步相关的指令就可以cache。所以只要上层提供encode结果缓存和重放的功能，被缓存的渲染指令就不需要重新计算同步指令。缓存的渲染指令本身就是一个优化，这个优化可以直接连带出同步指令计算的优化。上层应用采用这个优化的难度并不高，而且可以渐近迁移。这比framegraph要显式表达依赖整体迁移要合理许多。比如webgpu的renderbundle就是如此做法。

### 现代图形api采用显式同步的合理性

- 有一部分（少见）的case，无法**静态**的分析出不必要的依赖关系，这导致运行时会生成保守的或者不必要的同步。
  - 从资源本身的粒度上看是读写冲突的，但实际不冲突。比如交替位置读写
  - 读和写的行为完全由运行时数据决定
- 分析依赖然后生成同步指令本身，其实现是灵活的
  - 对于一个pipeline，我可以根据上面binding的类型和visibility来确定可能的读写，但visibility可能是乱填的，我也可以进一步看shader来分析读写
  - 实现方法有很多取舍，如果application能提供更多的信息，就可以做更多的优化。整个渲染本质上就是把scene渲染需求desciption高性能的翻译到gpu硬件command的description。如果我让图形api层面的description足够底层，比如需要显式同步，那么理论上application能够利用其自身的额外知识来做更加深入的优化（以更高的性能，生成所需要的 更精确的同步信息）
- 很多项目会使用图形封装层完成同步实现，而如果图形api再内置同步，那么生成同步指令的成本会翻倍。（除非封装层有配置可以关闭同步相关的计算

上文中，我们解决同步问题的具体方式，是某种形式某种层级的底层对象（同步结果）cache机制。而采用这种机制显然对于图形api的设计上会有较强的假设，而如果让用户负责同步，那么相关的cache设计也可以让用户来实现。

## 关于全局性优化的观点

采用framegraph的一个实质区别，就是延迟真正的图形提交，以加入全局性的分析。

有很多优化并不依赖于全局性的分析，比如资源reuse。实际上传统的即时模式，通过一个pool和所有权机制就能自动做到资源reuse，而且实现极其简单。

需要依赖整个pass graph图的完整信息才能做一些优化的情况是非常少的。即便能做一些事情，这些事情的实际收益一般是不值得支持维护一个类似实现。比如一个优化是控制pass graph执行过程中用到的峰值临时内存最小。那么显然是要做图相关的分析，控制执行流程，降低并行程度。但是这个收益是很难说是否值得投入做这件事情。

需要整个pass graph图的完整信息才能做到**最好的**优化，可能是没有必要的，但是即时模式让用户来直接表达这样的优化依然是可取的，这时候就不能保证做到理论上的最好。所以从足够好到理论上的最好，这个差别就更加倾向于不值得这么做。比如移动端的一些pass结构的改进。

一些资料甚至将剔除无用pass也罗列到framegraph优化之中。我认为是可笑的。首先framegraph是动态的（静态是不可能的，因为效果和行为在一直变化），一种做法是framegraph内置api来表达结构上的动态性，另一种是用户不把无关逻辑构造出graph，最后一种是用户总是构造最复杂的graph，然后交给runtime来剔除。这里边显然只有第二种做法称得上理智。

如果pass graph有必要做全局性的优化。那么应该直接实现于在即时模式的下层。即时模式提交的渲染命令，暂存到sumbit后，可以做任意的事情。比如这时候做相关的图分析工作。所以根本没有必要去要求用户直接通过api，显式的构造一个图结构。即便是即时模式，command的调用处依然可以在底层做成图构建的形式。

framegraph其实是想以compiler的思路来优化frame的workload。对于一个不符合预期的输出，你需要同时调试输入和编译器本身。其调试的成本非常高。

## 本身的overhead

如果你的frame根本不需要任何全局性的分析优化，那么引入这样的graph，就是纯粹的巨大的overhead。即便采用了这一做法，其引入的runtime overhead是否能cover其收益也是一个问题。

一个复杂的frame，有成百上千个resource和pass：

- 生成这个图本身就有不可忽视的cost
  - 所以在你需要在渲染结构本身没有改变，甚至任何依赖没有改变的情况下，cache这个图。一旦涉及到cache，那维护起来就有趣了
- 在这种规模的图上做任何复杂的分析是昂贵
  - 甚至仅仅是做一个拓扑排序也是昂贵的，然而采用即时模式，这样的顺序是静态保证的

## 很cool的visualization

visualization的目的是什么？

- 是为了做ppt来展示我们的渲染逻辑很复杂很高级（大可不必）
- 帮助理解渲染部分的数据流结构，帮助了解代码
- 定位和暴露潜在的问题

上文提到即时模式依然可以defer实际的图形提交来做任何事情，那么这个时候就可以做visualization。用过metal graphics debugger的就知道，录制frame后就可以直接就能把整个frame graph给你画出**界面**来。所以，我认为着一层的合理需求应该完全做在图形调试工具内。
