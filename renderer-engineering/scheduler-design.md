# 场景虚拟化实现的细节问题

基于[场景虚拟化](./scene-virtualization.md)的讨论，进一步讨论实现细节。

## feedback的实现方式

### drawlist based feedback

渲染器在准备渲染时生成的drawlist(一般是scenemodel list，也可以是其他位于特定剔除出口的list，比如meshlet)，收集剔除后的list。求和list中包含资源的计数作为资源的调度权重。

如果某些渲染逻辑使用不经过剔除的原始全集list，那么这样的list可以不被收集。因为它不提供差异化的权重。是否收集不经过剔除的非全集list，是具有争议的，从实际表现和性能开销触发，我认为这种list也不需要被收集。所以简单来说我们只收集被剔除后的list。

### framebuffer based feedback

渲染器在绘制时，添加并写入额外资源引用信息到额外的rendertaget上。求和target中资源的计数作为资源的调度权重。

因为framebuffer渲染的过程包含了per pixel的遮挡剔除，所以其总是包含有效的调度权重信息。

这种feedback方式一般用于virtual texture，但也能应用于其他资源。

## 权重计算在device还是host执行？

device实现有几个问题需要考虑：

- 简单实现即采用资源id线性buffer存储计数器，如果资源数量非常多，那么内存开销高。
- 可能需要处理所有feedback使用同一个资源造成contention的问题
- 在gpu本身满载的情况下，可能造成帧率抖动。

完备实现应该同时做device和host两种方案。优先实现host版本的权重计算。

## 权重衰减

用户在漫游场景的相机交互，大部分物体都被视锥剔除。同时处于背后的被视锥剔除的物体，又很容易重新出现于视线之中。环绕观察的场景，遮挡剔除也会有一样的问题。

简单的采用引用计数作为权重，会导致反复出现和消失的物体被反复调度。被剔除的资源的重要性权重直接归零，而使得其和哪些从来没有被调度进的资源具有一样的权重，这是不合理的。

一种简单的解决做法是，引入某种权重衰减的权重后处理机制，半衰期可以配置，以opt out相机切换场景下需要立刻卸载的需求。

## 执行调度计算的时机

执行调度计算即： 获取feedback，并根据feedback计算新的资源权重。

获取feedback要异步回读gpu数据，计算和排序权重的开销是昂贵的，需要在线程中异步完成。将排序后的权重交由streaming来更新加载请求的开销是昂贵的，需要异步在线程中完成。

当上一次的上述异步计算完成之后，才应该执行下一次feedback调度。

上述计算每一帧触发理论上是可以的，但是采用这种类似做法更加合理，因为

- 相机变化一般是连续的，高频的实时调度没有必要非常浪费。
- 调度的成本正比于被调度资源的数量。当用户场景规模增加，采用上述策略可以自动的降低调度触发的频率。使得调度总是不超过一个（给定个）线程不影响帧率的满载的性能容量

当用户场景足够小，调度频率会提高到每一帧级别。此时如果考虑减少不必要的绝对消耗（留出更多线程资源给其他常驻计算工作，或者减少功耗），也可以采用某种节流策略。

## 按需绘制的问题

- 场景渲染可能是按需的。比如某个viewport，某个shadowmap可能是按需绘制的。
- 根据上述讨论，调度计算不是每一帧都执行

所以调度计算需要发生的时刻，可能并没有场景渲染触发，导致根本没有feedback数据。如果不处理这种情况，那么会导致调度时恰好没有渲染的内容，被错误的page out。这并不是我们预期的合理行为。

所以针对这些可能被跳过的feedback，需要缓存最后一次执行的feedback结果。缓存最后一次执行的feedback结果其实是非常自然的，因为执行gpu数据回读，本身也需要target buffer，而target buffer本身就是需要被缓存的。

另外可考虑对应视图缓存weight的计算结果，当视图生命周期结束后，执行全局weight减去视图weight的逻辑。这种做法可以避免这种情况下的weight计算，但是实现较为复杂。

## 跳过调度计算

当场景中被调度的资源的cost之和，小于等于给定容量cost上限，那么调度weight的计算可以跳过。 同理如果cost之和小于等于带宽cost上限，那么整个streaming也不需要执行。
