# 场景数据虚拟化

本文主要讨论通过渲染虚拟化的实现框架。

虚拟化主要目的是通过 动态控制加载数据量，优先呈现对于用户更加重要的数据，来显示超过运行内存/显存的场景。一个设计和实现完备的虚拟化系统可以支持所谓的无限大场景显示的需求。

虚拟化的实现主要分为streaming（流式场景数据传输/更新）和scheduling（调度）两块内容。

## Streaming

根据[uri场景内容](./rebuildable-host-data.md)的讨论，streaming这部分的实现即 `DualQuery<K, MaybeUriData<T>>` 转化为 `DataChanges<K, T>`的过程。这个实现核心需要保证所有环节的内存使用不超过用户给定上限，并注重性能。streaming模块既不关心被调度对象的IO实现（完全由抽象uri负责），也不关心调度逻辑，完全通过读取weight输入决定。

内存不超过限制是核心能力，如果streaming的实现不能保证这一点，那么就完全没有意义和价值。这需要同时控制常驻内存使用（容量），和streaming时加载过程的临时内存使用（带宽），同时使用不超过限制缺一不可。控制带宽的目的不仅仅是控制加载时峰值内存的使用，另一个目的是通过控制正在进行加载的数据量，使得加载这一行为不会在某个时刻产生unbound的性能消耗，进而提高streaming的用户体验。

实现streaming，至少需要的per K的 常驻内存消耗，加载时峰值内存消耗，调度权重 三个信息。第一个信息由场景数据本身决定，峰值内存消耗即调用`f(K's url) -> V`加载过程的消耗（可能还需要估计后续处理管线的内存使用），由加载逻辑的实现和场景数据本身共同决定。调度权重由虚拟化的调度部分提供。

在具体实现中应采用抽象cost，而不是实际内存消耗byte作为cost。这样我们有机会采用其他的cost模型，从而同时考虑其他非内存消耗方面的容量问题。

调度权重的更新是异步的，低频率的, streaming系统访问的是最近一次权重的计算结果。数据streaming逻辑需要每一帧根据权重信息（k的weight），调整：当前在途的加载请求/带宽使用（哪些k处于loading的状态），当前需要被加载的数据但是因为带宽而排队（哪些k处于wait to load的状态），当前的实际加载集合（哪些k处于loaded状态）。并向下游输出`DataChanges<K, T>`

向下游输出`DataChanges<K, T>`其实是不准确的，合理的输出应是`DataChanges<K, LoadResult<T>>`,其中LoadResult是

```rust
pub enum LoadResult<T> {
  /// 完成加载的结果
  LivingOrLoaded(T),
  /// 应该被加载，但是加载失败
  PresentButFailedToLoad,
  /// 应该被加载，但是正在被加载
  PresentButNotLoaded,
}
```

这样下游datachanges的消费者可以获得更多信息，以实现合理的上层需求。比如正在加载的mesh采用bounding作为fallback显示，加载失败的mesh使用红色bounding作为警告显示。

用户可以配置，常驻内存总量，带宽总量，这两个指标来控制内存。带宽指标同时还配置了加载的速度。对于一个完备的streaming实现，这两个核心配置是可以被动态调整，配置总量以释放或加载更多场景数据，配置带宽以控制加载性能。streaming需要处理单个k的消耗超过全局限制的edge case（给出特定的警告信息）。

关于带宽总量配置，一种可能的改进是设置最大带宽使用和保守带宽容量两个配置。因为从内存控制的角度，在场景初次加载时，实际常驻内存是很低的，不考虑加载性能的控制，此时我们理论上可用的带宽是很高的。所以可用带宽应该主要由实际可用内存决定，这个状态下我们需要设置最大带宽使用来控制加载的性能消耗。然而到streaming进行到充分的情况，实际可用内存是极少的，此时我们需要保守带宽容量来保证有带宽来执行streaming。

## Scheduling

调度实现的主要工作是，给定某种场景单元K：输出per K的重要性信息（调度权重weight）。来量化某种资源对用户显示的重要性。权重的计算逻辑和所需数据，取决于我们需要什么样的调度行为，和目前渲染的实现方式。

streaming系统对权重没有任何更新逻辑上的假设，调度权重的计算一般是异步的，低频率的,甚至是可以部分更新的。weight的实际变化大部分是全集的，因为在渲染场景里，只要相机发生变化，所有的weight都需要重新计算。

### 调度逻辑的先验和后验

先验的调度，指我们从整个图形管线的最前端进行调度计算。通过我们对管线本身先验的知识，来估计和模拟后面实际执行的图形管线的显示特性。这种做法的优势在于我们可以在不执行完整管线的前提下进行资源调度。这个优势在某些情况下是必要的，因为用以支持调度的数据本身可能就需要调度，某种先验调度逻辑必须提前存在。

常见的估计方式比如：一般的，距离相机近，在屏幕上显示面积大，就是重要的。所以朴素的直接根据bounding和距离计算重要性。在采用了传统LOD的渲染方式上，还需要考虑mesh/model error相关的信息，来降权距离相机遥远的低level数据。

后验的调度，指我们在在整个图形管线的最后端进行调度计算。在渲染中添加调度所需的执行结果，进行后续分析来获得哪些资源需要被调度的信息。这种方式的效果是最理想的。因为它直接根据执行的实际情况输出调度需求。但是依赖更多数据，具有较高的前提条件。

### weight transformation

先验调度的计算需要从[场景基本单元](../editor-engineering/basic-scene-object-model.md)出发，因为基本单元是渲染的入口，真正决定了绘制的内容，而不是其间接引用的资源，因为某个资源实例可能被渲染/使用多次。

但是场景基本单元一般并不是以K寻址的调度资源。比如一般来说对于场景我们会从scene model入手计算其重要性，即scenemodel weight。但是我们要调度的K，可能是texture。从 scene model 到texture 其中存在多层的多对一关系。所以scenemodel weight需要以某种方式transform到texture weight上。transformation可以考虑weight transformation实现为简单的多对一add逻辑。

后验的调度直接输出资源的需求，它看起来不需要weight transformation，但是实际上它在资源需求的统计过程中（计数）本身就在device上完成了weight transformation。

### device和host的调度实现

host调度

- 不能实现后验的调度逻辑，因为我们讨论的是gpu渲染器
- 不依赖device，没有兼容性问题
- 因为weight的实际变化大部分是全集的。所以host调度除非采用分配部分更新的方式，否则其能支持的数据集非常有限。
- 绝对性能差

device调度

- 可以同时实现两种调度能力
  - 全集的高性能先验调度，weight传播，排序，都可以在device上高效实现
  - 有效的后验调度完全依赖于device能力。比如texture的调度，我们会依赖framebuffer的feedbacktexutre，这相当于使用了per pixel的遮挡能力。
- 性能好，依赖device，一般可以处理海量全集数据

### 防抖动逻辑

防抖动逻辑是一个独立的模块，可以认为是对weight计算的后处理。可以简单的将防抖动adhoc的实现为weight数值变化的稳定器。

## 地址转化

调度输入不是稀疏的，但是调度的结果一定是稀疏的。因为要最小化内存使用，所以实际retain的数据不可能是稀疏的，需要采用另一套方式寻址。资源总是需要以input的space进行寻址，用户认为原始input数据实际都存在，但是实际上物理它不一定存在，从虚拟地址input，到实际物理数据都需要做某种性质地址转化。

## 虚拟化实现的组合

当我们完成对加载，streaming，调度，等模块的拆分。具体业务无关的reuseable的实现就可以被整理出来，同时我们可以看到虚拟化本身可以被实现为结构化的可组合的框架。

### 虚拟化的水平组合

一个渲染器可能存在多种资源需要虚拟化。其具备不同的loading实现，streaming容量的配置，和调度的实现。所谓水平组合就是这种平行的虚拟化系统共存的形态。

水平组合需要考虑streaming容量的协调问题。一个富texture少mesh的场景，用户应该给予texture streaming系统更高的配额。这里可能有动态的全局控制器的设计空间。

### 虚拟化的垂直组合

一种资源要实现虚拟化，其必须先存在uri形态的数据和支持先验调度的相关数据，我们称之为虚拟化的元数据，当我们讨论一个非常大的场景的虚拟化。这些元数据本身也是无法存在于内存之内的，也需要虚拟化。

所谓虚拟化的垂直组合就是嵌套的虚拟化。上游虚拟化系统控制的数据，作为（n个）下游虚拟化系统依赖的元数据。外层调度的结果决定了内层调度的空间。虚拟化框架因此实际是一个图的结构。

宇宙级别的系统决定星球级别的系统哪些星球是active的，星球级别的系统决定哪些地区是active，地区级别的系统决定哪些社区是active，然后到实际哪些scenemodel资源是active的，最后是哪些mesh texture是active的（实际加载的）。

调度实现可以针对不同的资源类型同时存在多个，在顶层配置每一块调度器的limitation。比如在整体上限确定的情况下，如果场景富几何但是贴图简单，那么应该提高几何部分的配给，反之亦然。

### 改进行为

调度的行为需要符合上层业务的预期，比如在社交媒体上经常被展示的一些游戏的bug：对话的时候只有眼球的模型但是没有脸部的模型，路上行人行走直接以绑定时的T-pose平移。解决这一问题，可能需要引入特别的优先级模型，或者在streaming部分支持给定场景物体的加载的回调能力。

另一个有趣的问题是，对于开放世界大场景，如果玩家移动到了没有被加载的位置该如何处理。比如加载后发现玩家处于一个非法位置。这个问题其实可以简单的解决：碰撞检测的场景数据本身是虚拟化的，其调度具有高的优先级。玩家必须在碰撞检测加载后完成的区域活动，否则会有空气墙。考虑到碰撞检测数据并不大，所以玩家更可能遇到碰撞到还没有加载的物体，然而这是完全可以接受的。无限场景/开放世界的用户体验，更多的决定于用户的绝对加载带宽，所谓我们看到现在很多游戏要求用户最低配置使用SSD硬盘。

其他实现细节讨论，[见](./scheduler-design.md)
