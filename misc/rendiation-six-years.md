# Rendiation 六年开发回顾

[rendiation](https://github.com/mikialex/rendiation)是我在19年12月14日创建的side project，距今天约整六年。做一个简单的回顾，并总结一下这六年来让我坚持投入到这个项目的原因和有效实践。

## 不断进化的 ship of thesues

最早当时开这个坑的背景是：我在18年初毕业实习开始开始做webgl的渲染优化，到19年底时我的工作让我对web上做基础软件开发的合理性充满质疑，所以19年底开始我试图尝试做一些非web上的渲染实现。

这6年里我提交了超过5k+ commit。每一年都有重大的技术决策变更和重构，根据工具统计，今天写的代码，一年后平均只会存留一半。现在和几年前的codebase从实现角度看几乎不是一个项目。

在rendiation的开发上，我一直落实一个务实的工程方法论：先写一个垃圾出来。

- 因为知道是垃圾，所以没有任何心理负担，多糟糕也没关系，只要能work
- 把垃圾做出来的过程
  - 才知道垃圾为什么是垃圾
  - 才知道怎么改进
  - 才能学习到做改进的通用方法
  - 才能知道什么是重要，什么是不重要的
  - 才能看懂好东西
  - 才能有可能发现更好的做法
- 能够避免过早的不合适的优化
- 垃圾有时也有可取之处，垃圾做出来不一定会抛弃，可能在某些场景是有用的，甚至是必要的
- 一般很快就能做出来，做出来能work，能提供很好的正面反馈

好的技术是生长出来的，是从一个垃圾的状态迭代改进而来的。不存在被规划出来的好的结果。 从具体的场景，推导出必要的技术方向，然后做一个barely work的实现，然后长期的迭代改进。从现有实现（约束） + 现有问题（目标） 生长出 具体迭代改进。这个过程同时发生在很多尺度，很多位置。不合适的，被证明是错误的实践被删除和裁剪。

rendiation的进化代表和体现了我在编程和渲染上的理解以及具体手艺的进化。在这样的进化过程中，我探索了渲染器工程，数据和计算框架方面的设计空间。学习和实现了诸多图形渲染上的知识。现有实现具有丰富的技术细节。

在过去的每一年，我都会认为去年的代码写的很垃圾。rendiation的历史就是垃圾进化的历史。理论上我应该每年总结一次当年的开发情况，但之前几乎没有这么做。今天我认为rendiation到现在差不多整体上，方向上，终于改进/进化到了一个我觉得可以拿得出手的，不能再简单的称之为垃圾的状态。

## “团队合作”

现在整个rendiation有108k行rust代码，其中甚至几乎没有测试代码。

这个规模代码有时对我来说已经进入到一种奇妙的状态：

- 我现在只知道整个项目的宏观picture，和过去1周-1个月touch过的微观细节
- 有时候我需要把自己之前写的代码当书来看，来重新探索和了解之前的想法
- 当我认为某些地方需要改进时，我需要重新学习之前我的怎么写的，以及我之前编写的接口细节
- 曾经出现过，我偶然想到一个巧妙的改进，但当我回到项目里发现我之前已经实现，而且做的更好

当项目成长到一定规模，即便只有一个人开发，也得学会团队合作。你需要学会在 过去的自己，现在的自己，和将来的自己 之间进行团队合作。因为遗忘，所以一个人的项目也存在沟通的成本。和不同时间的rendiation是不同的rendiation一样，不同时间的自己是不同的自己，有不同的想法和思考。你需要在时间的维度和不同的自己实现团队合作来产出好的作品。

如果做出好的东西，如果做出有用的东西。那么出现真的团队合作只是时间问题。团队合作的重点从来不是因为要团队，而是因为要合作。复杂度达到了一定规模，超出了一个人的mental capacity，就会出现合作。在协作上的投入（无论是文档还是流程），其重要目的是让一个人在任意时间片上可以单独的维护整个项目（另一个重要目的是能够并行工作），使得项目本身不会因为人的因素而收到影响。

在前司的某小会议室的墙上有这样的鸡汤大致意思是「一个人可以走的很快，但只有一群人才能走的远」。这句话隐含的意思是，短期内因为不需要团队合作的原因，一个人可以凭借个人能力快速取得一些突破。但是工作量的规模，复杂度，持续时间是大大超出一个人的个人能力的，所以团队协作是必需的，所以只有一群人的团队协作才能实现一个成规模的长期项目。我认为从时间和规模的角度来说，rendiation本身已经体现了这个说法的荒谬。走的快，或者走的远，和人数没有关系，主要取决于项目本身协作层面的健康度（裁到只剩一个关键人也不会死）和项目本身的健康度（项目本身能够在一个关键人的认知容量情况下高效维护）。

回到问题本身，从实际实践看，我认为这些是重要的：

- 识别重要的东西，经常了解重要的东西，遗忘不重要的东西
- 对重要的东西，编写详细的设计文档，详细到为什么这么做和为什么不那么做
- 正确和统一的命名
- 合理的注释

beside上述这些事项，最重要的还是「设计和实现统一的，可组合的，经得起时间考验的高质量架构」

## 成本控制

在code size 超过了工作记忆容量，但依然能够高效维护和演进设计的核心原因，就是通过「设计和实现统一的，可组合的，经得起时间考验的高质量架构」来实现的。rendiaiton的主要成果是工程上的，工程是控制复杂度的艺术，控制复杂度的目的是控制成本。

rendiation的核心子框架主要通过这些方面来控制工程成本，并取得了非常好的效果，这里具体不再展开。

- 消除偶然复杂度
  - db
- 可递归组合的抽象
  - query
  - composeable component model
- 在非性能热区的部分通过动态性来改进代码结构
  - edsl shader， hooks

我之所以如此关注工程方面的内容，并不只是我热衷于做这件事情，而是控制成本对于一个我要超长期开发的side project是重中之重，也是rendiation能长期维护的核心原因。rendiation是side project，所谓成本就是时间（当然如果对于一个企业来说，再乘以时薪，那就是钱了）。成本控制就是减少不必要的时间消耗在不必要的地方上。

- 能够少写代码，少看代码，少重新学习代码
- 编写容易学习的代码
- 能够自己定义轮子造轮子组合轮子
- 能够暴露重要的细节，行为足够合理，不给自己挖坑
- 能够调试/容易建设调试能力
- 能够表达非常动态和复杂的需求
- 能够通过静态检查避免低级错误（rendiation也是我于19年终总结“all in rust”的标志）

在公司项目上，曾经因为工程上的问题导致的痛苦经历，和令人发指的低效，让我意识到一个好的工程建设对比糟糕的工程建设，其效率会产生数量级的差别。然而在公司里，你很难说服manager在工程向的研究进行投资是必要的，而一般visible可交付的feature和效能改进才能被认可。在rendiation，我只需要关注一件事，就是工程上怎么写的爽（当然技术上需要合理）怎么来。不需要任何人认可和解释（当然实际要说服自己）。最终反而让我觉得在rendiation上的技术成果更加重要和可靠。

## “坚持”

与其说这六年来我坚持投入到这个项目，不如说这六年来我“坚持”投入到这个项目。实际上这个过程完全不需要坚持，不需要努力，完全是享受。

rendiation对我来说是一件逻辑严密，复杂精巧的玩具。

- 图形学可玩性本身就很高
- 完备的工程化建设让我写的很舒服
- 探索和解决工程问题的过程令我兴奋
- 没有时间和目标的压力
- 可以同时做多个不同的东西
- 可以任何时候放弃和继续
- 持续的输出正面的高频的正反馈

如今rendiation不仅是个玩具，并逐渐成长成熟为一个可用的工具

- 完备的gltf类似规格的3d viewer
  - 可以直接dogfooding离线数据处理方面的实现
  - 可以作为实时渲染的独立解决方案接入到其他产品中
- 一个实践和学习图形技术的通用平台

很多管理方法，都追求所谓「结果导向」。结果导向是错误的，因为过程和结果本身是一体的。你实际上无法只关注结果而不考虑过程，你只能通过关注过程来影响结果。当你说“不管中间过程怎么怎么样，最后我只看结果”，实际上你说的是，“这件事情和我没任何关系，我只是最后根据结果给你发钱”。有的情况下，在没有实际过程发生之前，规划具体的结果是不可靠的，甚至我们想要什么结果也是不确定的。「过程导向」则是设定方向，而不是结果，去**培育**好的改变，通过优化过程本身来达成更好的结果。即便未能取得好的进展，总结成果和被探索过的地图本身就是有用的结果。好的「过程」，是不需要坚持的坚持，是充满正反馈的过程。

## 未来方向

无论我是否继续从事图形开发方面的职业，rendiation会始终持续长期维护

虽然我现在对技术上的现状比较满意，但这不意味着rendiation会整体永远进入一个非常稳定的情况，追求稳定意味着拒绝变化的可能，拒绝变化就是拒绝改进。在工程上的探索和改进会一直继续下去。

短期1-2年的开发计划是

- 实现表内数据mesh和texture的虚拟化
- 改进和丰富效果实现
- indirect后端默认采用meshlet管线，采用meshlet shader

长期方向是

- 维护一个gltf like的scene api
- 维护一个高质量高性能的3d viewer
- 基于这个平台实现独立的上层功能，比如3d-gui, editor, physics集成，更多文件格式和数据源的支持
- 考虑visualization(robotics/bim/gis), 游戏等方向的机会
