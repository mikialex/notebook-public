# hooks pattern

所谓hooks-like pattern，即类似于react hooks的编程技巧：用户编写函数，通过以固定顺序调用状态访问或创建函数，以使得能够访问到上一次该函数的该状态，可以使得连续多次的函数运行之间可以持久化状态。

## hooks的限制

以react hooks为例，hooks的使用限制是：必须在控制流之外以固定顺序调用。这个原因是易于理解的，因为只有这样才能正确访问状态，状态的正确访问依赖于稳定的访问顺序。

这个限制可以被解除。比如rust可以静态的得到某个函数的call site信息（`#[track_caller]`）。所以状态的正确访问可以不用依赖于稳定的访问顺序，而是直接用call site去寻址。

## 以运行性能换取编程体验

hooks pattern可以desugar成传统的编程方式，由此我们可以看到这一技术主要是以运行性能换取编程体验

- 用户连续的通过hooks访问持久化的状态 =等价于= 用户静态的访问静态定义的struct，每一个field就是零散的状态
  - 用户不需要定义struct，省去了代码。但是相比静态的访问，动态的在array上寻址，判断和检查类型，引入了额外的成本。特别是如果采用上述hooks限制解锁的实现，即采用hashmap寻址，也会引入更高的成本。判断和检查类型可能可以unsafe的关闭，但是这样可能会引入正确性的风险。
  - 假设struct field的清理函数不是简单的drop，而是特别的方法。用户需要显式的为struct编写cleanup函数。而hooks相当于一个动态容器，可以自动的为每一个field触发cleanup
- 对于包含控制流的代码，即view的liveness是动态的由数据决定的情况，hooks自动的创建的删除view =等价于= 用户通过For或者IF view组建表达控制流逻辑（类似于通过类型构造模版）
  - 降低了编程的理解成本，提高了维护性。不需要编写控制流组件，某些复杂的控制逻辑也很难翻译成控制流组件，提供了自由的表达能力。但是性能相比控制流组件是较差的。
- 函数式的组件，只有一个code path。
  - 好处是用户不用为上述等价struct实现多个方法。当方法本身具备扩展性时，不需要为所有的struct添加内层的转发实现。
  - 所以无法区分创建stage和更新stage，即只有更新stage，创建stage是更新的特例。意味着更新stage也必须传递创建stage所需的参数，那么意味着某些参数传递在更新stage是浪费的。这些浪费可能可以缓解，但是无法避免。所以引入了额外的运行成本
  - 所以无法区分不同类型的更新stage，只能动态的判断更新类型，所以引入了额外的运行成本。而不同的更新流程总是要访问所有的数据（至少取到引用，而这也是有成本的）
