# Hooks pattern

所谓hooks-like pattern，即类似于react hooks的编程技巧：用户编写函数，通过以某种规则调用函数，使得这次函数调用可以访问到上一次该函数调用的状态，即可以使得连续多次的函数运行之间可以持久化状态。这种能力一般通过在一个cx对象上获得，比如一个典型的hook式代码如

```rust
fn my_logic(cx: &mut HookCx){
  let a = cx.use_state::<u32>(); // a: &mut u32
  let b = cx.use_state::<f32>(); // b: &mut f32
}
```

以某种方式，对该函数进行多次调用，多次调用会访问到相同a，b可变引用。 这种函数内部局部数据的持久化方法， 在不改变函数的形态或者引入更多概念的情况下，使得计算本身直接就是可重入的。本文主要叙述一种基于这样的hooks的编程框架/模式的设计细节。

## Hooks的行为和规则

以react hooks为例，hooks的使用限制是：必须在控制流之外以固定顺序调用。这个原因是易于理解的，因为实际状态存储在vec里，只有这样才能正确访问状态，状态的正确访问依赖于稳定的访问顺序。

这个限制可以被解除。比如rust可以静态的得到某个函数的call site信息（`#[track_caller]`）。所以状态的正确访问可以不用依赖于稳定的访问顺序，而是直接用call site去寻址。但是考虑到连续的存储和访问状态，具有更好的访问性能，默认情况下，我们依然要求连续访问，只有遇到控制流时需要特别的api进行辅助：

### Hook scope

这一特别api称之为scope，对于存在控制流以至于不能保证状态的访问顺序固定的情况，用户需要通过scope来包裹在控制流内的代码，scope内的数据访问规则可以继续使用顺序访问。scope是通过call site进行寻址的。

```rust
fn my_logic(cx: &mut HookCx, env: bool){
  let a = cx.use_state::<u32>(); // a: &mut u32
  if env {
    cx.scope(|cx|{
      let b = cx.use_state::<f32>(); // b: &mut f32
    })
  }
}
```

scope可以嵌套，用户调用函数的过程，其实就是访问一个scope tree的过程。用户的state实际上就持久化在这样的tree上。hook的入口函数（即根部），也是一个scope。

因为scope在branch内，所以scope本身和scope上的数据的生命周期是动态的。在执行完scope后，框架会自动释放该scope内没有被访问到的scope，并执行上面的状态的销毁方法。所以scope本身不仅用于支持控制流，还用于支持和控制流绑定的动态数据生命周期管理。

### 抽象的Hookcx

实际上，HookCx并不是一个确定的类型，而是个trait。任何类型只要满足相关实现，以支持上述的基本功能都可以实现。这使得我们可以自己定义Cx来扩展Hook的能力。一般来说，现在在Cx上的扩展，比较重要的模式是：

多stage Cx：比如Cx实际上是一个枚举。然后框架给出这样的规定：该Cx枚举的variant会按照一定规则依次出现并调用hook逻辑，每一次调用称之为一个stage，hook逻辑要在不同的stage内做不同的事情来完成需求。比如可以用hooks来实现retain ui，有event和update两个stage。event处理输入，update处理视图变更。分stage的必要性在于这两个stage中数据的可变性是相反的。另一个典型例子是用来以一种非常简单和动态的方式实现[组合创建组合](./composition-create-composition.md)的设计模式，比如第一个stage创建组合，第二个stage使用这个组合。

支持wake：比如Cx上有waker，即整个hook函数和future/stream的poll方法一样。只有底层被wake，上层才进入，以此实现性能优化。

融合其他外部ctx，比如database style的外部数据，比如gpu resource的管理。

## 以运行性能换取编程体验

hooks pattern可以desugar成传统的编程方式，由此我们可以看到这一技术主要是以运行性能换取编程体验

- 用户连续的通过hooks访问持久化的状态 =等价于= 用户静态的访问静态定义的struct，每一个field就是零散的状态
  - 用户不需要定义struct，省去了代码。但是相比静态的访问，动态的在array上寻址，判断和检查类型，引入了额外的成本。特别是如果采用上述hooks限制解锁的实现，即采用hashmap寻址，也会引入更高的成本。判断和检查类型可能可以unsafe的关闭，但是这样可能会引入正确性的风险。
  - 假设struct field的清理函数不是简单的drop，而是特别的方法。用户需要显式的为struct编写cleanup函数。而hooks相当于一个动态容器，可以自动的为每一个field触发cleanup
- 对于包含控制流的代码，即view的liveness是动态的由数据决定的情况，hooks自动的创建的删除view =等价于= 用户通过For或者IF view组建表达控制流逻辑（类似于通过类型构造模版）
  - 降低了编程的理解成本，提高了维护性。不需要编写控制流组件，某些复杂的控制逻辑也很难翻译成控制流组件，提供了自由的表达能力。但是性能相比控制流组件是较差的。
- 函数式的组件，只有一个code path。
  - 好处是用户不用为上述等价struct实现多个方法。当方法本身具备扩展性时，不需要为所有的struct添加内层的转发实现。
  - 所以无法区分创建stage和更新stage，即只有更新stage，创建stage是更新的特例。意味着更新stage也必须传递创建stage所需的参数，那么意味着某些参数传递在更新stage是浪费的。这些浪费可能可以缓解，但是无法避免。所以引入了额外的运行成本
  - 所以无法区分不同类型的更新stage，只能动态的判断更新类型，所以引入了额外的运行成本。而不同的更新流程总是要访问所有的数据（至少取到引用，而这也是有成本的）

## hooks的适用之处

如果某部分的实现

- 需要持久化状态，即有struct定义来存储状态
- 总是存在成对的方法需要轮流调用，即这些struct总是有一堆一样的方法需要轮流调用
- 状态的生命周期动态性很高
- 不追求极致性能/操作不涉及需要优化的热区
- 设计上强调组合和扩展

那么迁移到hooks上是非常合适，因为以hooks方式编写的代码，存储状态的struct定义，构造，释放，不同类型的方法调用的组合胶水代码，全部都不需要写（或者说只需要编写一份），能少写很多。因为组合点只需要定义一次，所以代码上看不同需要组合的逻辑和状态的依赖点只有一个，所以组合性和代码阅读的locality都大幅提升。可以有效改进项目的维护性。
