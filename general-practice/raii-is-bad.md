# RAII is bad(in some case)

RAII指的是通过控制对象的生命周期来控制某种资源的生命周期。 对象创建时资源创建，对象销毁时资源销毁。

资源销毁需要访问资源相关的ctx, 因为需要调用释放资源的接口。资源销毁的逻辑需要编写于对象的drop函数内，又因为drop函数是没有其他入参的，所以对象本身就需要能够访问到上述ctx。(另一种做法是采用定制的消耗self的函数，比如`fn should_call_this_for_drop(self, ctx: Ctx)`。但是目前没有任何机制去静态的保证用户不会调用原始的drop方法。)，而要使得对象能够访问到上述ctx，那么意味着对象需要持有ctx的引用计数指针。进一步的，可能需要采用内部可变性容器来允许使用mutatble方法。

所以RAII其实要付出性能代价。具体而言，每一个对象的内存大小增加了，每一个对象创建都需要修改ctx的引用计数，每一个drop触发时都需要defer ptr，access lock/refcell，以及修改ctx的引用计数。

如果用户采用**海量**的这样的对象进行资源管理，那么会付出非常巨大的性能代价。曾经我采用这样的机制管理上百万的对象，在应用结束退出时，需要等待超过1分钟才能完成对象销毁。

## reference readings

<https://faultlore.com/blah/linear-rust/>
